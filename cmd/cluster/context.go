package cluster

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"
	"time"

	pd "github.com/PagerDuty/go-pagerduty"
	jira "github.com/andygrunwald/go-jira"
	"github.com/aws/aws-sdk-go/service/cloudtrail"
	"github.com/openshift-online/ocm-cli/pkg/dump"
	sdk "github.com/openshift-online/ocm-sdk-go"
	"github.com/openshift/osdctl/cmd/servicelog"
	sl "github.com/openshift/osdctl/internal/servicelog"
	"github.com/openshift/osdctl/pkg/osdCloud"
	"github.com/openshift/osdctl/pkg/osdctlConfig"
	"github.com/openshift/osdctl/pkg/printer"
	"github.com/openshift/osdctl/pkg/utils"
	"github.com/rodaine/table"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	cmdutil "k8s.io/kubectl/pkg/cmd/util"
)

type contextOptions struct {
	output            string
	verbose           bool
	full              bool
	clusterID         string
	externalClusterID string
	baseDomain        string
	organizationID    string
	days              int
	pages             int
	oauthtoken        string
	usertoken         string
	externalID        string
	infraID           string
	awsProfile        string
	jiratoken         string
}

const (
	jiraHost                      = "https://issues.redhat.com"
	JiraTokenConfigKey            = "jira_token"
	JiraTokenRegistrationUrl      = "https://issues.redhat.com/secure/ViewProfile.jspa?selectedTab=com.atlassian.pats.pats-plugin:jira-user-personal-access-tokens"
	PagerDutyOauthTokenConfigKey  = "pd_oauth_token"
	PagerDutyUserTokenConfigKey   = "pd_user_token"
	PagerDutyTokenRegistrationUrl = "https://martindstone.github.io/PDOAuth/"
)

// newCmdContext implements the context command to show the current context of a cluster
func newCmdContext() *cobra.Command {
	ops := newContextOptions()
	contextCmd := &cobra.Command{
		Use:               "context",
		Short:             "Shows the context of a specified cluster",
		Args:              cobra.ExactArgs(1),
		DisableAutoGenTag: true,
		Run: func(cmd *cobra.Command, args []string) {
			cmdutil.CheckErr(ops.complete(cmd, args))
			cmdutil.CheckErr(ops.run())
		},
	}

	contextCmd.Flags().StringVarP(&ops.clusterID, "cluster-id", "C", "", "Cluster ID")
	contextCmd.Flags().StringVarP(&ops.awsProfile, "profile", "p", "", "AWS Profile")
	contextCmd.Flags().BoolVarP(&ops.verbose, "verbose", "", false, "Verbose output")
	contextCmd.Flags().BoolVar(&ops.full, "full", false, "Run full suite of checks.")
	contextCmd.Flags().IntVarP(&ops.days, "days", "d", 30, "Command will display X days of Error SLs sent to the cluster. Days is set to 30 by default")
	contextCmd.Flags().IntVar(&ops.pages, "pages", 40, "Command will display X pages of Cloud Trail logs for the cluster. Pages is set to 40 by default")
	contextCmd.Flags().StringVar(&ops.oauthtoken, "oauthtoken", "", fmt.Sprintf("Pass in PD oauthtoken directly. If not passed in, by default will read `pd_oauth_token` from ~/.config/%s.\nPD OAuth tokens can be generated by visiting %s", osdctlConfig.ConfigFileName, PagerDutyTokenRegistrationUrl))
	contextCmd.Flags().StringVar(&ops.usertoken, "usertoken", "", fmt.Sprintf("Pass in PD usertoken directly. If not passed in, by default will read `pd_user_token` from ~/config/%s", osdctlConfig.ConfigFileName))
	contextCmd.Flags().StringVar(&ops.jiratoken, "jiratoken", "", fmt.Sprintf("Pass in the Jira access token directly. If not passed in, by default will read `jira_token` from ~/.config/%s.\nJira access tokens can be registered by visiting %s", osdctlConfig.ConfigFileName, JiraTokenRegistrationUrl))

	return contextCmd
}

func newContextOptions() *contextOptions {
	return &contextOptions{}
}

func (o *contextOptions) complete(cmd *cobra.Command, args []string) error {
	if len(args) != 1 {
		return cmdutil.UsageErrorf(cmd, "Provide exactly one cluster ID")
	}

	if o.days < 1 {
		return fmt.Errorf("cannot have a days value lower than 1")
	}

	// Create OCM client to talk to cluster API
	ocmConnection := utils.CreateConnection()
	defer func() {
		if err := ocmConnection.Close(); err != nil {
			fmt.Printf("Cannot close the ocmClient (possible memory leak): %q", err)
		}
	}()

	clusters := utils.GetClusters(ocmConnection, args)
	if len(clusters) != 1 {
		return fmt.Errorf("unexpected number of clusters matched input. Expected 1 got %d", len(clusters))
	}

	cluster := clusters[0]
	o.clusterID = cluster.ID()
	o.externalClusterID = cluster.ExternalID()
	o.baseDomain = cluster.DNS().BaseDomain()
	o.externalID = cluster.ExternalID()
	o.infraID = cluster.InfraID()

	orgID, err := utils.GetOrgfromClusterID(ocmConnection, *cluster)
	if err != nil {
		fmt.Printf("Failed to get Org ID for cluster ID %s - err: %q", o.clusterID, err)
		o.organizationID = ""
	} else {
		o.organizationID = orgID
	}

	return nil
}

func (o *contextOptions) run() error {

	ocmConnection := utils.CreateConnection()
	defer ocmConnection.Close()

	jiraClient, err := createJiraClient()

	// err = printClusterInfo(o.clusterID)
	// if err != nil {
	// 	return err
	// }

	cluster, err := utils.GetCluster(ocmConnection, o.clusterID)
	cluster.

		// Check support status of cluster
		err = o.printSupportStatus(ocmConnection)
	if err != nil {
		return err
	}

	// Print support exceptions
	err = o.printSupportExceptions(jiraClient)
	if err != nil {
		return err
	}

	// Print the Servicelogs for this cluster
	err = o.printServiceLogs()
	if err != nil {
		return err
	}

	err = o.printJiraCards(jiraClient)
	if err != nil {
		return err
	}

	// // Print all triggered and acknowledged pd alerts
	// err = o.printPDAlerts()
	// if err != nil {
	// 	fmt.Fprintf(os.Stderr, "Can't print pagerduty alerts: %v\n", err)
	// 	// Here we don't actually want to error out, this is to ensure that even if we don't have the
	// 	// pd auth setup, we can still get the rest of the output.
	// }

	// // Print other helpful links
	// err = o.printOtherLinks()
	// if err != nil {
	// 	fmt.Fprintf(os.Stderr, "Can't print other links: %v\n", err)
	// }

	if o.full {
		err = o.printCloudTrailLogs()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Can't print cloudtrail: %v\n", err)
			os.Exit(1)
		}
	} else {
		fmt.Println()
		fmt.Println("============================================================")
		fmt.Println("CloudTrail events for the Cluster")
		fmt.Println("============================================================")
		fmt.Println("Not polling cloudtrail logs, use --full flag to do so (must be logged into the correct hive to work).")
	}

	return nil
}

func printClusterInfo(clusterID string) error {
	cmd := "ocm describe cluster " + clusterID
	output, err := exec.Command("bash", "-c", cmd).Output()
	if err != nil {
		fmt.Println(string(output))
		fmt.Print(err)
		return err
	}
	fmt.Println(string(output))

	return nil
}

// printSupportStatus reports if a cluster is in limited support or fully supported.
func (o *contextOptions) printSupportStatus(conn *sdk.Connection) error {

	var r result
	r.service = "Support Status and Exceptions"
	defer r.printResult()

	limitedSupportReasons, err := utils.GetClusterLimitedSupportReasons(conn, o.clusterID)
	if err != nil {
		return err
	}

	if len(limitedSupportReasons) == 0 {
		r.context = "Cluster is fully supported"
	} else {
		r.context = "Cluster has Limited Support"
	}

	r.columns = []string{"ID", "Summary", "Details"}
	for _, clusterLimitedSupportReason := range limitedSupportReasons {
		r.items = append(r.items, []string{clusterLimitedSupportReason.ID, clusterLimitedSupportReason.Summary, clusterLimitedSupportReason.Details})
	}

	return nil
}

// printServiceLogs prints a list of servicelogs for the cluster
func (o *contextOptions) printServiceLogs() error {

	var r result
	r.service = "Service Logs"
	defer r.printResult()

	// Get the SLs for the cluster
	slResponse, err := servicelog.FetchServiceLogs(o.clusterID)
	if err != nil {
		return err
	}

	var serviceLogs sl.ServiceLogShortList
	err = json.Unmarshal(slResponse.Bytes(), &serviceLogs)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal the SL response: %v", err)
	}

	// Parsing the relevant servicelogs
	// - We only care about SLs sent in the past 'o.days' days
	var errorServiceLogs []sl.ServiceLogShort
	for _, serviceLog := range serviceLogs.Items {
		// If the days since the SL was sent exceeds o.days days, we're not interested
		if (time.Since(serviceLog.CreatedAt).Hours() / 24) > float64(o.days) {
			continue
		}

		errorServiceLogs = append(errorServiceLogs, serviceLog)
	}

	if o.verbose {
		marshalledSLs, err := json.MarshalIndent(errorServiceLogs, "", "  ")
		if err != nil {
			return err
		}
		dump.Pretty(os.Stdout, marshalledSLs)
	} else {
		r.columns = []string{"#", "Summary", "Created"}
		for i, errorServiceLog := range errorServiceLogs {
			r.items = append(r.items, []string{fmt.Sprint(i), errorServiceLog.Summary, errorServiceLog.CreatedAt.Format(time.RFC3339)})
		}
	}

	return nil
}

func getPDUserClient(usertoken string) (*pd.Client, error) {
	if usertoken == "" {
		if !viper.IsSet(PagerDutyUserTokenConfigKey) {
			return nil, fmt.Errorf("key %s is not set in config file", PagerDutyUserTokenConfigKey)
		}
		usertoken = viper.GetString(PagerDutyUserTokenConfigKey)
	}
	return pd.NewClient(usertoken), nil
}

func getPDOauthClient(oauthtoken string) (*pd.Client, error) {
	if oauthtoken == "" {
		if !viper.IsSet(PagerDutyOauthTokenConfigKey) {
			return nil, fmt.Errorf("key %s is not set in config file", PagerDutyOauthTokenConfigKey)
		}
		oauthtoken = viper.GetString(PagerDutyOauthTokenConfigKey)
	}
	return pd.NewOAuthClient(oauthtoken), nil
}

func GetPagerdutyClient(usertoken string, oauthtoken string) (*pd.Client, error) {
	client, err := getPDUserClient(usertoken)
	if client != nil {
		return client, err
	}
	client, err = getPDOauthClient(oauthtoken)
	if err != nil {
		return nil, fmt.Errorf("failed to create both user and oauth clients for pd")
	}
	return client, err
}

func getPDSeviceID(pdClient *pd.Client, ctx context.Context, baseDomain string) (string, error) {
	lsResponse, err := pdClient.ListServicesWithContext(ctx, pd.ListServiceOptions{Query: baseDomain})

	if err != nil {
		fmt.Printf("Failed to ListServicesWithContext %q\n", err)
		return "", err
	}

	if len(lsResponse.Services) != 1 {
		return "", fmt.Errorf("unexpected number of services matched input. Expected 1 got %d", len(lsResponse.Services))
	}

	return lsResponse.Services[0].ID, nil
}

func printCurrentPDAlerts(pdClient *pd.Client, ctx context.Context, serviceID string) error {
	fmt.Println("============================================================")
	fmt.Println("Current Pagerduty Alerts for the Cluster")
	fmt.Println("============================================================")
	fmt.Println()
	fmt.Printf("Link to PD Service: https://redhat.pagerduty.com/service-directory/%s\n", serviceID)
	fmt.Println()

	liResponse, err := pdClient.ListIncidentsWithContext(
		ctx,
		pd.ListIncidentsOptions{
			ServiceIDs: []string{serviceID},
			Statuses:   []string{"triggered", "acknowledged"},
			SortBy:     "urgency:DESC",
		},
	)
	if err != nil {
		fmt.Printf("Failed to ListIncidentsWithContext %q\n", err)
		return err
	}

	if len(liResponse.Incidents) == 0 {
		fmt.Println("")
	}

	tbl := table.New("Urgency", "Title", "Created")
	for _, incident := range liResponse.Incidents {
		tbl.AddRow([]string{incident.Urgency, incident.Title, incident.CreatedAt})
	}
	tbl.Print()
	return nil
}

func printHistoricalPDAlertSummary(pdClient *pd.Client, ctx context.Context, serviceID string) error {

	fmt.Println("============================================================")
	fmt.Println("Historical Pagerduty Alert Summary")
	fmt.Println("============================================================")
	fmt.Println()
	fmt.Printf("Link to PD Service: https://redhat.pagerduty.com/service-directory/%s\n", serviceID)
	fmt.Println()

	var currentOffset uint
	var limit uint = 100
	var incidents []pd.Incident

	for currentOffset = 0; true; currentOffset += limit {
		// pd defaults pulling the past month of data, which is enough for us to work with
		liResponse, err := pdClient.ListIncidentsWithContext(
			ctx,
			pd.ListIncidentsOptions{
				ServiceIDs: []string{serviceID},
				Statuses:   []string{"resolved", "triggered", "acknowledged"},
				Offset:     currentOffset,
				Limit:      limit,
				SortBy:     "created_at:desc",
			},
		)

		if err != nil {
			return err
		}

		if len(liResponse.Incidents) == 0 {
			break
		}

		incidents = append(incidents, liResponse.Incidents...)
	}
	println()

	type occurrenceTracker struct {
		incidentCount  int
		lastOccurrence string
	}

	incidentCounter := make(map[string]*occurrenceTracker)

	var incidentKeys []string
	for _, incident := range incidents {
		title := strings.Split(incident.Title, " ")[0]
		if _, found := incidentCounter[title]; found {
			incidentCounter[title].incidentCount++

			// Compare current incident timestamp vs our previous 'latest occurrence', and save the most recent.
			currentLastOccurence, err := time.Parse(time.RFC3339, incidentCounter[title].lastOccurrence)
			if err != nil {
				fmt.Printf("Failed to parse time %q\n", err)
				return err
			}

			incidentCreatedAt, err := time.Parse(time.RFC3339, incident.CreatedAt)
			if err != nil {
				fmt.Printf("Failed to parse time %q\n", err)
				return err
			}

			// We want to see when the latest occurrence was
			if incidentCreatedAt.After(currentLastOccurence) {
				incidentCounter[title].lastOccurrence = incident.CreatedAt
			}

		} else {
			// First time encountering this incident type
			incidentCounter[title] = &occurrenceTracker{
				incidentCount:  1,
				lastOccurrence: incident.CreatedAt,
			}

			incidentKeys = append(incidentKeys, title)
		}
	}

	if len(incidentKeys) == 0 {
		fmt.Println("No historical pagerduty data")
		fmt.Println()
		return nil
	}

	sort.SliceStable(incidentKeys, func(i, j int) bool {
		return incidentCounter[incidentKeys[i]].incidentCount > incidentCounter[incidentKeys[j]].incidentCount
	})

	tbl := table.New("Type", "Count", "Last Occurrence")

	for _, k := range incidentKeys {
		tbl.AddRow([]string{k, strconv.Itoa(incidentCounter[k].incidentCount), incidentCounter[k].lastOccurrence})
	}

	tbl.Print()

	totalIncidents := len(incidents)
	oldestIncidentTimestamp, err := time.Parse(time.RFC3339, incidents[totalIncidents-1].CreatedAt)
	if err != nil {
		fmt.Printf("Failed to parse time %q\n", err)
		return err
	}
	oldestIncidentTimeInDays := int(time.Since(oldestIncidentTimestamp).Hours() / 24)
	fmt.Println("Total number of incidents [", totalIncidents, "] in [", oldestIncidentTimeInDays, "] days")

	return nil
}

func createJiraClient() (*jira.Client, error) {
	if !viper.IsSet(JiraTokenConfigKey) {
		return nil, fmt.Errorf("key %s is not set in config file", JiraTokenConfigKey)
	}

	jiratoken := viper.GetString(JiraTokenConfigKey)

	tp := jira.PATAuthTransport{
		Token: jiratoken,
	}

	jiraClient, err := jira.NewClient(tp.Client(), jiraHost)
	if err != nil {
		return nil, err
	}

	return jiraClient, nil
}

func (o *contextOptions) printJiraCards(client *jira.Client) error {

	var r result
	r.service = "OHSS Cards"
	defer r.printResult()

	jql := fmt.Sprintf(
		`(project = "OpenShift Hosted SRE Support" AND "Cluster ID" ~ "%s") 
		OR (project = "OpenShift Hosted SRE Support" AND "Cluster ID" ~ "%s") 
		ORDER BY priority DESC, Status DESC`,
		o.externalClusterID,
		o.clusterID,
	)

	issues, _, err := client.Issue.Search(jql, nil)
	if err != nil {
		return fmt.Errorf("Failed getting Jira issues: %q\n", err)
	}

	r.columns = []string{"Key", "Fields", "Priority", "Summary", "Status", "Link"}

	for _, i := range issues {
		r.items = append(r.items, []string{
			i.Key,
			i.Fields.Type.Name,
			i.Fields.Priority.Name,
			i.Fields.Summary, i.Fields.Status.Name,
			fmt.Sprintf("https://issues.redhat.com/browse/%s\n\n", i.Key),
		})
	}

	return nil
}

func (o *contextOptions) printSupportExceptions(jiraClient *jira.Client) error {

	var r result
	defer r.printResult()

	if o.organizationID == "" {
		return errors.New("No Organization ID specified for cluster")
	}

	jql := fmt.Sprintf(
		`project = "Support Exceptions" AND type = Story AND Status = Approved AND
		 Resolution = Unresolved AND "Customer Name" ~ "%s"`,
		o.organizationID,
	)

	issues, _, err := jiraClient.Issue.Search(jql, nil)
	if err != nil {
		fmt.Printf("Failed to search for jira issues %q\n", err)
		return err
	}

	r.columns = []string{"Key", "Fields", "Priority", "Summary", "Status", "Link"}

	for _, i := range issues {
		r.items = append(r.items, []string{
			i.Key,
			i.Fields.Type.Name,
			i.Fields.Priority.Name,
			i.Fields.Summary, i.Fields.Status.Name,
			fmt.Sprintf("https://issues.redhat.com/browse/%s\n\n", i.Key),
		})
	}

	return nil
}

func (o *contextOptions) printPDAlerts() error {

	pdClient, err := GetPagerdutyClient(o.usertoken, o.oauthtoken)
	if err != nil {
		fmt.Println("error getting pd client: ", err.Error())
		return err
	}

	ctx := context.TODO()
	serviceID, err := getPDSeviceID(pdClient, ctx, o.baseDomain)
	if err != nil {
		fmt.Println("error getting pd service id: ", err.Error())
		return err
	}

	err = printCurrentPDAlerts(pdClient, ctx, serviceID)
	if err != nil {
		fmt.Println("error calling printCurrentPDAlerts: ", err.Error())
		return err
	}

	err = printHistoricalPDAlertSummary(pdClient, ctx, serviceID)
	if err != nil {
		fmt.Println("error calling printHistoricalPDAlertSummary: ", err.Error())
		return err
	}

	return nil
}

func (o *contextOptions) printOtherLinks() error {

	fmt.Println("============================================================")
	fmt.Println("External resources containing related cluster data")
	fmt.Println("============================================================")

	fmt.Printf("Link to Splunk audit logs (set time in Splunk): https://osdsecuritylogs.splunkcloud.com/en-US/app/search/search?q=search%%20index%%3D%%22openshift_managed_audit%%22%%20clusterid%%3D%%22%s%%22\n\n", o.infraID)
	fmt.Printf("Link to OHSS tickets: https://issues.redhat.com/issues/?jql=project%%20%%3D%%20OHSS%%20and%%20(%%22Cluster%%20ID%%22%%20~%%20%%20%%22%s%%22%%20OR%%20%%22Cluster%%20ID%%22%%20~%%20%%22%s%%22)\n\n", o.clusterID, o.externalID)
	fmt.Printf("Link to CCX dashboard: https://kraken.psi.redhat.com/clusters/%s\n\n", o.externalID)

	return nil
}

func (o *contextOptions) printCloudTrailLogs() error {

	awsJumpClient, err := osdCloud.GenerateAWSClientForCluster(o.awsProfile, o.clusterID)
	if err != nil {
		return err
	}

	foundEvents := []*cloudtrail.Event{}
	var eventSearchInput = cloudtrail.LookupEventsInput{}

	fmt.Println("Pulling and filtering the past", o.pages, "pages of Cloudtrail data")
	for counter := 0; counter <= o.pages; counter++ {
		print(".")
		cloudTrailEvents, err := awsJumpClient.LookupEvents(&eventSearchInput)
		if err != nil {
			return err
		}

		foundEvents = append(foundEvents, cloudTrailEvents.Events...)

		// for pagination
		eventSearchInput.NextToken = cloudTrailEvents.NextToken
		if cloudTrailEvents.NextToken == nil {
			break
		}
	}
	fmt.Println()
	fmt.Println("============================================================")
	fmt.Println("Potentially interesting CloudTrail events for the Cluster")
	fmt.Println("============================================================")

	table := printer.NewTablePrinter(os.Stdout, 20, 1, 3, ' ')
	table.AddRow([]string{"EventId", "EventName", "Username", "EventTime"})
	for _, event := range foundEvents {
		if skippableEvent(*event.EventName) {
			continue
		}
		if event.Username == nil {
			table.AddRow([]string{*event.EventId, *event.EventName, "", event.EventTime.String()})
		} else {
			if strings.Contains(*event.Username, "RH-SRE-") {
				continue
			}
			table.AddRow([]string{*event.EventId, *event.EventName, *event.Username, event.EventTime.String()})
		}

	}
	// Add empty row for readability
	table.AddRow([]string{})
	err = table.Flush()
	if err != nil {
		fmt.Println("error while flushing table: ", err.Error())
		return err
	}

	return nil
}

// These are a list of skippable aws event types, as they won't indicate any modification on the customer's side.
func skippableEvent(eventName string) bool {
	skippableList := []string{
		"Get",
		"List",
		"Describe",
		"AssumeRole",
		"Encrypt",
		"Decrypt",
		"LookupEvents",
		"GenerateDataKey",
	}

	for _, skipword := range skippableList {
		if strings.Contains(eventName, skipword) {
			return true
		}
	}
	return false
}

type result struct {
	// the name of the service being checked
	service string
	// the column headers to include in the results
	columns []string
	// The results themselves
	// as a slice of a slice of strings
	items [][]string
	// Any contextual info that needs to be added
	context string
}

// makeInterface converts a []string to an interface
func makeInterface(s []string) []interface{} {
	i := make([]interface{}, len(s))
	for x := range s {
		i[x] = s[x]
	}
	return i
}

// printResult returns results in a standardized, easy to read format
func (r *result) printResult() {
	if r.service != "" {
		fmt.Println(r.service)
		fmt.Println(strings.Repeat("-", len(r.service)))
		// This will print a newline if there's not a hidden service name
		// eg: Support Exceptions, that are included in Support Status
		defer fmt.Println()
	}

	// Exit if we have nothing to print
	if len(r.items) != 0 {

		tbl := table.New(makeInterface(r.columns)...)

		for _, item := range r.items {
			tbl.AddRow(makeInterface(item)...)
		}

		tbl.Print()
	}

	if r.context != "" {
		fmt.Println(r.context)
	}

	return
}
